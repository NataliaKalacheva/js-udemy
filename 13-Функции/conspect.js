//ФУНКЦИИ

function nameOfFunction(firstName = "Default", lastName = "Default") {
  //после параметра = можем указать значение по умолчанию(если аргументы не переданы)
  //в скобках параметры
  console.log("Тело функции");
  console.log(firstName, lastName);
  return `Hello ${firstName} ${lastName}`; //если return не задан, то при сохранении функции в переменную, эта переменная будет undefined. ПОСЛЕ RETURN ФУНКЦИЯ ДАЛЬШЕ НЕ ВЫПОЛНЯЕТСЯ!
}
let res = nameOfFunction("Natalia"); //вызов функции. Можно вызывать перед самой функцией, т.к. бразуер при обработке выносит все функции вверх. В скобках АРГУМЕНТЫ.
//Функции не должны менять глобальные переменные!
let res2 = nameOfFunction("Natalia", "Kalacheva") + "!";

console.log(res);
console.log(res2);

//ОБЛАСТЬ ВИДИМОСТИ ФУНКЦИИ

//Глобальные - все без обертки

let x = 10;

function foo() {
  x = 20;
  console.log(x);
}

foo();

console.log(x); //Функция нашла переменную в глобальном пространстве и изменила ее. ЭТО ПЛОХАЯ ПРАКТИКА!

//Если мы объявляем переменную в функции - она считается локальной! Если мы указываем глобальную переменную в кач-ве параметра - это все равно, что объявить ее внутри функции!

const user = {
  name: "Natalia",
  age: 24
};

function getObj(obj) {
  obj.name = "Tata";
}

getObj(user);
console.log(user); //ВЫВЕДЕТСЯ ИЗМЕНЕННЫЙ ОБЪЕКТ, т.к. мы передали ссылку на объект и она его изменила

//function expression - еще один метод создания функций

const square = function(x) {
  return x * x;
};
//Мы НЕ МОЖЕМ ВЫЗВАТЬ ФУНКЦИЮ ДО ПРИСВОЕНИЯ В ПЕРЕМЕННУЮ
console.log(square(10));

//САМОВЫЗЫВАЮЩИЕСЯ ФУНКЦИИ
//часто в такие функции заворачивают весь код. Страховка от конфликтов имен переменных.
(function(msg) {
  console.log(msg);
})("Hello world!");
